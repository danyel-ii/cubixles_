<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>cubixles_ world (Bruno-style)</title>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
      }
    }
  </script>
  <style>
    :root{
      --bg:#07090c;
      --fg:#e9eef6;
      --muted:#a9b3c1;
      --line:#1e2530;
      --panel:#0e1218ee;
      --panel2:#101722f2;
      --accent:#7af0ff;
      --good:#7cff9b;
      --warn:#ffdc7a;
      --bad:#ff7a9b;
      --shadow: 0 18px 60px rgba(0,0,0,.55);
      --r:16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--fg); font-family:var(--sans); overflow:hidden;}
    canvas{display:block; width:100%; height:100%;}
    .hud{
      position:fixed; inset:0; pointer-events:none;
      background:
        radial-gradient(1200px 700px at 20% 10%, rgba(122,240,255,.10), transparent 60%),
        radial-gradient(900px 700px at 80% 15%, rgba(155,140,255,.08), transparent 55%),
        radial-gradient(900px 700px at 50% 110%, rgba(124,255,155,.05), transparent 55%);
    }
    .topbar{
      position:fixed; left:14px; right:14px; top:12px;
      display:flex; gap:12px; align-items:flex-start; justify-content:space-between;
      pointer-events:none;
    }
    .brand{
      pointer-events:auto;
      border:1px solid var(--line);
      background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border-radius: var(--r);
      padding: 10px 12px;
      box-shadow: var(--shadow);
      max-width: 680px;
      backdrop-filter: blur(10px);
    }
    .brand h1{margin:0; font-size:14px; letter-spacing:.2px;}
    .brand p{margin:6px 0 0; font-size:12px; color:var(--muted); line-height:1.35;}
    .pillrow{
      pointer-events:auto;
      display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; align-items:center;
    }
    .pill{
      border:1px solid var(--line);
      background:rgba(0,0,0,.25);
      border-radius:999px;
      padding: 7px 10px;
      font-size: 12px;
      color: rgba(233,238,246,.92);
      display:flex; gap:8px; align-items:center;
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
      cursor:pointer;
      user-select:none;
      pointer-events:auto;
    }
    .pill:hover{border-color: rgba(122,240,255,.35);}
    .dot{width:8px; height:8px; border-radius:50%; background:var(--accent); box-shadow: 0 0 0 3px rgba(122,240,255,.12);}
    .dot.good{background:var(--good); box-shadow:0 0 0 3px rgba(124,255,155,.10);}
    .dot.warn{background:var(--warn); box-shadow:0 0 0 3px rgba(255,220,122,.10);}
    .dot.bad{background:var(--bad); box-shadow:0 0 0 3px rgba(255,122,155,.10);}

    .controls{
      position:fixed; left:14px; bottom:14px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.28);
      border-radius: var(--r);
      padding: 10px 12px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      max-width: 520px;
      pointer-events:auto;
    }
    .controls .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
    .kbd{
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.28);
      padding: 2px 6px;
      border-radius: 8px;
      font-family: var(--mono);
      font-size: 11px;
      color: rgba(233,238,246,.92);
    }
    .controls .small{margin-top:6px; color:var(--muted); font-size:11.5px; line-height:1.35;}
    .hint{
      position:fixed; left:50%; transform:translateX(-50%);
      bottom: 14px;
      border:1px solid rgba(122,240,255,.25);
      background: rgba(122,240,255,.08);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 12px;
      color: rgba(233,238,246,.95);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      display:none;
      pointer-events:none;
    }
    .hint strong{color:var(--accent);}
    .map{
      position:fixed; right:14px; bottom:14px;
      width: 210px; height: 210px;
      border-radius: 18px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.28);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      pointer-events:none;
      display:none;
      overflow:hidden;
    }
    .map .label{
      position:absolute; left:10px; top:8px;
      font-size: 11px; color: var(--muted);
    }
    .map canvas{width:100%; height:100%;}
    .toast{
      position:fixed; right:14px; top:78px;
      display:flex; flex-direction:column; gap:10px;
      pointer-events:none;
      max-width: 360px;
    }
    .toast .t{
      pointer-events:none;
      border:1px solid rgba(124,255,155,.20);
      background: rgba(124,255,155,.08);
      border-radius: 14px;
      padding: 10px 12px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      color: rgba(233,238,246,.95);
      font-size: 12px;
      line-height:1.35;
    }
    .toast .t b{color:var(--good);}

    /* Info panel */
    .backdrop{
      position:fixed; inset:0; background: rgba(0,0,0,.62);
      display:none; align-items:flex-end; justify-content:center;
      padding: 14px; z-index: 10;
    }
    .backdrop.open{display:flex;}
    .panel{
      width: min(920px, 100%);
      max-height: min(86vh, 860px);
      border-radius: 22px;
      border:1px solid rgba(255,255,255,.10);
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      box-shadow: var(--shadow);
      overflow:hidden;
      display:flex; flex-direction:column;
    }
    .panelhead{
      display:flex; align-items:flex-start; justify-content:space-between;
      gap:10px; padding: 14px 16px 12px;
      border-bottom: 1px solid rgba(255,255,255,.08);
    }
    .panelhead .title{
      display:flex; flex-direction:column; gap:4px;
    }
    .panelhead h2{margin:0; font-size:16px; letter-spacing:.2px;}
    .panelhead .sub{margin:0; font-size:12px; color:var(--muted);}
    .panelhead .close{
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      color: var(--fg);
      border-radius: 12px;
      padding: 8px 10px;
      cursor:pointer;
      font-size: 12px;
      pointer-events:auto;
    }
    .panelhead .close:hover{border-color: rgba(122,240,255,.35);}
    .panelbody{
      padding: 12px 16px 16px;
      overflow:auto;
      font-size: 13px;
      color: rgba(233,238,246,.92);
      line-height:1.45;
    }
    .panelbody h4{
      margin: 14px 0 6px;
      font-size: 12px;
      letter-spacing:.18em;
      text-transform: uppercase;
      color: rgba(169,179,193,.95);
    }
    .panelbody ul{margin: 8px 0 0; padding-left: 18px;}
    .panelbody li{margin: 6px 0;}
    .mono{
      font-family: var(--mono);
      font-size: 12.5px;
      background: rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.10);
      padding: 10px 12px;
      border-radius: 12px;
      overflow:auto;
      margin: 10px 0;
      color: rgba(233,238,246,.92);
    }
    .cta{
      margin-top: 12px;
      border:1px solid rgba(122,240,255,.22);
      background: rgba(122,240,255,.07);
      border-radius: 16px;
      padding: 12px 12px;
      color: rgba(233,238,246,.92);
    }
    .cta b{color: var(--accent);}

    /* Mobile tweaks */
    @media (max-width: 760px){
      .controls{max-width: calc(100% - 28px);}
      .map{display:none !important;}
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="hud"></div>

  <div class="topbar">
    <div class="brand">
      <h1>cubixles_ world</h1>
      <p>
        Bruno-style driveable 3D primer — except you drive a <strong>cubixle</strong>.
        Landscape expands into billboard “flat images” (placeholder art) for major PFPs.
        Replace billboard textures with your own URLs if you have rights to use them.
      </p>
    </div>
    <div class="pillrow">
      <div class="pill" id="btnAudio" title="Toggle ambient hum"><span class="dot"></span> Audio</div>
      <div class="pill" id="btnQuality" title="Toggle quality / performance"><span class="dot warn"></span> Quality</div>
      <div class="pill" id="btnRespawn" title="Respawn cubixle"><span class="dot bad"></span> Respawn</div>
      <div class="pill" id="btnHelp" title="Show / hide controls"><span class="dot good"></span> Help</div>
    </div>
  </div>

  <div class="controls" id="controls">
    <div class="row">
      <span class="kbd">WASD</span> / <span class="kbd">ARROWS</span> move
      <span class="kbd">SHIFT</span> boost
      <span class="kbd">SPACE</span> hop
      <span class="kbd">ENTER</span> interact
      <span class="kbd">M</span> map
      <span class="kbd">R</span> respawn
      <span class="kbd">L</span> mute
      <span class="kbd">drag</span> rotate camera
      <span class="kbd">wheel</span> zoom
    </div>
    <div class="small">
      Skeptic mode: drive to any billboard, press <span class="kbd">ENTER</span>, and read the “verify” checklist.
      This is an original implementation inspired by the interaction grammar of bruno-simon.com.
    </div>
  </div>

  <div class="hint" id="hint"></div>

  <div class="map" id="map">
    <div class="label">map (M)</div>
    <canvas id="mapCanvas" width="210" height="210"></canvas>
  </div>

  <div class="toast" id="toast"></div>

  <div class="backdrop" id="backdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="panel" role="document">
      <div class="panelhead">
        <div class="title">
          <h2 id="panelTitle">Title</h2>
          <p class="sub" id="panelSub">Subtitle</p>
        </div>
        <button class="close" id="panelClose" aria-label="Close panel">Close</button>
      </div>
      <div class="panelbody" id="panelBody"></div>
    </div>
  </div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
    import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";
    import * as CANNON from "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js";

    // -----------------------------
    // Data: “major PFPs” billboards
    // -----------------------------
    // IMPORTANT: These billboards use generated placeholder textures (no copyrighted imagery).
    // Replace imageUrl with your own URLs if you have the rights to use them.
    const BILLBOARD_DEFS = [
      { id:"punks", name:"CryptoPunks", tag:"canon", imageUrl:null,
        primer:`Punks are the canonical “trait rarity” era: scarcity via frequency tables inside one collection. cubixles_ proposes an upgrade: scarcity via executed relations across collections.`,
        relate:`cubixles_ treats provenance as geometry: not “rare hat,” but “rare configuration.” It can externalize cross-collection adjacency (e.g., punk-holder acquires X) as a tradable record.`,
      },
      { id:"bayc", name:"Bored Ape Yacht Club", tag:"pfp", imageUrl:null,
        primer:`A dominant PFP social object: identity, culture, and liquidity often compress to entry=buy / exit=sell.`,
        relate:`cubixles_ adds “exit = synthesize”: trade contextual derivatives without liquidating the underlying identity asset.`,
      },
      { id:"azuki", name:"Azuki", tag:"pfp", imageUrl:null,
        primer:`A strong brand + style system; markets price objects + floor dynamics.`,
        relate:`cubixles_ creates a second layer where context can be priced (relations, configurations, curation).`,
      },
      { id:"doodles", name:"Doodles", tag:"pfp", imageUrl:null,
        primer:`Another closed-world trait system: valuable primarily as an object inside its own collection.`,
        relate:`cubixles_ makes inter-collection relations priceable: adjacency becomes an economic act.`,
      },
      { id:"pudgy", name:"Pudgy Penguins", tag:"pfp", imageUrl:null,
        primer:`A cultural meme machine with strong distribution dynamics.`,
        relate:`cubixles_ turns meme adjacency into a minted artifact: “this was held with that, now.”`,
      },
      { id:"milady", name:"Milady", tag:"pfp", imageUrl:null,
        primer:`Conviction collectors often don’t want to sell; the asset functions as cultural capital.`,
        relate:`cubixles_ is built for this posture: keep the originals; externalize context as the tradable unit.`,
      },
      { id:"nakamigos", name:"Nakamigos", tag:"pfp", imageUrl:null,
        primer:`A recent PFP with strong memetic forms; relevance often shows up as wallet crossover stories.`,
        relate:`cubixles_ can capture those stories as executed configurations (minted relations), not just tweets.`,
      },
      { id:"clonex", name:"CloneX", tag:"pfp", imageUrl:null,
        primer:`High-production identity objects; markets price brand + scarcity within the set.`,
        relate:`cubixles_ prices the relation graph: overlap, arrangement, and executed adjacency.`,
      },
      { id:"moonbirds", name:"Moonbirds", tag:"pfp", imageUrl:null,
        primer:`Another “closed set” rarity economy.`,
        relate:`cubixles_ broadens the price surface: context becomes the economic object.`,
      },
      { id:"coolcats", name:"Cool Cats", tag:"pfp", imageUrl:null,
        primer:`PFP-era mechanics popularized trait meta and collection-internal ranking.`,
        relate:`cubixles_ upgrades the scarcity signal from frequency tables to network structure.`,
      },

      // Concept nodes (to keep the world “about cubixles_”)
      { id:"productive", name:"Productive Rights", tag:"concept", imageUrl:null,
        primer:`Ownership as the right to compose: your holdings become inputs to new market objects.`,
        relate:`In Builder track, ownership is verified at mint time; nothing is escrowed. You point; you mint.`,
      },
      { id:"geometry", name:"Provenance as Geometry", tag:"concept", imageUrl:null,
        primer:`Scarcity signal shifts from trait frequency → network structure.`,
        relate:`cubixles_ makes geometry operational: configuration gates minting and routes value.`,
      },
      { id:"routing", name:"Value Routing", tag:"concept", imageUrl:null,
        primer:`Curation becomes market formation when it routes proceeds to referenced works.`,
        relate:`Builder mints route mint-time payouts to each referenced NFT’s royalty receiver (when compatible).`,
      },
      { id:"skeptic", name:"Skeptic Checklist", tag:"verify", imageUrl:null,
        primer:`Mint the smallest cube and verify the primitive: no custody, legible pricing, observable routing.`,
        relate:`If those checks pass, the “primitive” claim is real—even if you still dislike the aesthetics.`,
      },
    ];

    // -----------------------------
    // Three.js setup
    // -----------------------------
    const canvas = document.getElementById("c");
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x07090c, 0.02);

    // Soft gradient-ish background (approx)
    scene.background = new THREE.Color(0x07090c);

    const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 600);
    camera.position.set(0, 10, 16);

    // Controls: orbit-like camera around cubixle (mouse drag)
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.enablePan = false;
    controls.minDistance = 8;
    controls.maxDistance = 42;
    controls.maxPolarAngle = Math.PI * 0.48;
    controls.minPolarAngle = Math.PI * 0.16;

    // Lights
    const hemi = new THREE.HemisphereLight(0x9dbbff, 0x151a22, 0.85);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 1.1);
    dir.position.set(12, 22, 8);
    dir.castShadow = false;
    scene.add(dir);

    const accent = new THREE.PointLight(0x7af0ff, 1.1, 40, 2);
    accent.position.set(-10, 6, -8);
    scene.add(accent);

    // Ground
    const groundGeo = new THREE.PlaneGeometry(400, 400, 1, 1);
    const groundMat = new THREE.MeshStandardMaterial({
      color: 0x0b0f15,
      roughness: 0.92,
      metalness: 0.05
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI/2;
    ground.position.y = 0;
    scene.add(ground);

    // "Road" rings (visual guidance)
    const ringGroup = new THREE.Group();
    scene.add(ringGroup);

    function addRing(radius, color=0x1e2733){
      const geo = new THREE.RingGeometry(radius-0.22, radius+0.22, 96);
      const mat = new THREE.MeshBasicMaterial({ color, transparent:true, opacity:0.55, side:THREE.DoubleSide });
      const ring = new THREE.Mesh(geo, mat);
      ring.rotation.x = -Math.PI/2;
      ring.position.y = 0.01;
      ringGroup.add(ring);
    }
    addRing(14, 0x1b2430);
    addRing(28, 0x1a2230);
    addRing(44, 0x18202d);
    addRing(62, 0x151d29);

    // --------------------------------
    // Cannon physics (simple & stable)
    // --------------------------------
    const world = new CANNON.World({
      gravity: new CANNON.Vec3(0, -9.82, 0),
    });
    world.broadphase = new CANNON.SAPBroadphase(world);
    world.allowSleep = true;

    // Materials
    const matGround = new CANNON.Material("ground");
    const matCube = new CANNON.Material("cube");
    world.addContactMaterial(new CANNON.ContactMaterial(matGround, matCube, {
      friction: 0.3,
      restitution: 0.05,
    }));

    // Ground body
    const groundBody = new CANNON.Body({ mass: 0, material: matGround });
    groundBody.addShape(new CANNON.Plane());
    groundBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
    world.addBody(groundBody);

    // Cubixle visual + body
    const cubixleSize = 1.35;
    const cubixleGeo = new THREE.BoxGeometry(cubixleSize, cubixleSize, cubixleSize);

    const glassMat = new THREE.MeshPhysicalMaterial({
      color: 0x9fefff,
      roughness: 0.08,
      metalness: 0.0,
      transmission: 0.92,
      thickness: 0.8,
      ior: 1.45,
      transparent: true,
      opacity: 1.0,
      clearcoat: 0.7,
      clearcoatRoughness: 0.18,
      emissive: new THREE.Color(0x061017),
      emissiveIntensity: 0.35,
    });

    const cubixleMesh = new THREE.Mesh(cubixleGeo, glassMat);
    cubixleMesh.position.set(0, 1.2, 0);
    scene.add(cubixleMesh);

    // Subtle edges
    const edges = new THREE.LineSegments(
      new THREE.EdgesGeometry(cubixleGeo, 22),
      new THREE.LineBasicMaterial({ color: 0x7af0ff, transparent:true, opacity:0.6 })
    );
    cubixleMesh.add(edges);

    // Halo base pad
    const padGeo = new THREE.CircleGeometry(2.2, 64);
    const padMat = new THREE.MeshBasicMaterial({ color: 0x7af0ff, transparent:true, opacity:0.08 });
    const pad = new THREE.Mesh(padGeo, padMat);
    pad.rotation.x = -Math.PI/2;
    pad.position.set(0, 0.02, 0);
    scene.add(pad);

    // Cube body (physics)
    const cubixleBody = new CANNON.Body({
      mass: 3.0,
      material: matCube,
      position: new CANNON.Vec3(0, 1.2, 0),
      linearDamping: 0.12,
      angularDamping: 0.9,
    });
    cubixleBody.addShape(new CANNON.Box(new CANNON.Vec3(cubixleSize/2, cubixleSize/2, cubixleSize/2)));
    cubixleBody.allowSleep = false;
    world.addBody(cubixleBody);

    // Keep cubixle upright-ish (lock tilt)
    const up = new CANNON.Vec3(0,1,0);
    let heading = 0; // yaw, radians
    let speed = 0;

    // Obstacles / ramps
    const obstacles = new THREE.Group();
    scene.add(obstacles);

    function addBumper(x,z, w=2.6,h=0.8,d=0.8, color=0x1f2a36){
      const mesh = new THREE.Mesh(
        new THREE.BoxGeometry(w,h,d),
        new THREE.MeshStandardMaterial({ color, roughness:0.9, metalness:0.05 })
      );
      mesh.position.set(x, h/2, z);
      obstacles.add(mesh);

      const body = new CANNON.Body({ mass:0, material: matGround });
      body.addShape(new CANNON.Box(new CANNON.Vec3(w/2,h/2,d/2)));
      body.position.set(x, h/2, z);
      world.addBody(body);
    }

    function addRamp(x,z, w=3.5,h=0.5,d=6.0, angle=0.22, color=0x1a2230){
      const mesh = new THREE.Mesh(
        new THREE.BoxGeometry(w,h,d),
        new THREE.MeshStandardMaterial({ color, roughness:0.9, metalness:0.05 })
      );
      mesh.position.set(x, h/2, z);
      mesh.rotation.x = -angle;
      obstacles.add(mesh);

      const body = new CANNON.Body({ mass:0, material: matGround });
      body.addShape(new CANNON.Box(new CANNON.Vec3(w/2,h/2,d/2)));
      body.position.set(x, h/2, z);
      body.quaternion.setFromEuler(-angle, 0, 0);
      world.addBody(body);
    }

    addBumper(0, -8);
    addBumper(8, 0, 0.8, 0.8, 2.6);
    addBumper(-8, 0, 0.8, 0.8, 2.6);
    addRamp(-10, 16, 3.4, 0.5, 7.0, 0.18);
    addRamp(12, 22, 3.4, 0.5, 7.0, 0.22);

    // -----------------------------
    // Toasts (used by early init)
    // -----------------------------
    const toastEl = document.getElementById("toast");
    let toastTimer = null;
    function toast(html){
      const div = document.createElement("div");
      div.className = "t";
      div.innerHTML = html;
      toastEl.appendChild(div);
      clearTimeout(toastTimer);
      toastTimer = setTimeout(() => {
        div.style.opacity = "0";
        div.style.transform = "translateY(-6px)";
        div.style.transition = "opacity .25s ease, transform .25s ease";
        setTimeout(()=>div.remove(), 260);
      }, 1800);
    }

    // -----------------------------
    // Billboard world (flat images)
    // -----------------------------
    const billboardGroup = new THREE.Group();
    scene.add(billboardGroup);

    // Create placeholder textures via canvas (evocative “flat images”)
    function makeCardTexture(label, tag){
      const c = document.createElement("canvas");
      c.width = 512; c.height = 512;
      const ctx = c.getContext("2d");

      // background gradient
      const g = ctx.createLinearGradient(0,0,512,512);
      g.addColorStop(0, "#0b0f15");
      g.addColorStop(0.55, "#101a26");
      g.addColorStop(1, "#0a0d12");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,512,512);

      // grid
      ctx.globalAlpha = 0.25;
      ctx.strokeStyle = "#1f2a36";
      for(let i=0;i<=16;i++){
        const p = i*(512/16);
        ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,512); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(512,p); ctx.stroke();
      }
      ctx.globalAlpha = 1;

      // badge
      const badge = tag ? tag.toUpperCase() : "PFP";
      ctx.font = "700 20px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
      const bw = ctx.measureText(badge).width + 28;
      ctx.fillStyle = "rgba(122,240,255,0.12)";
      ctx.strokeStyle = "rgba(122,240,255,0.35)";
      ctx.lineWidth = 2;
      roundRect(ctx, 24, 26, bw, 36, 18, true, true);
      ctx.fillStyle = "rgba(233,238,246,0.92)";
      ctx.fillText(badge, 38, 52);

      // icon-ish glyph
      ctx.save();
      ctx.translate(256, 256);
      ctx.rotate(Math.PI/10);
      ctx.globalAlpha = 0.9;
      ctx.strokeStyle = "rgba(122,240,255,0.65)";
      ctx.lineWidth = 5;
      ctx.beginPath();
      ctx.rect(-120, -120, 240, 240);
      ctx.stroke();
      ctx.lineWidth = 3;
      ctx.globalAlpha = 0.35;
      for(let i=0;i<6;i++){
        ctx.rotate(Math.PI/3);
        ctx.beginPath();
        ctx.moveTo(0,-110); ctx.lineTo(0,-60);
        ctx.stroke();
      }
      ctx.restore();

      // title
      ctx.fillStyle = "rgba(233,238,246,0.95)";
      ctx.font = "800 40px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
      wrapText(ctx, label, 40, 380, 432, 48);

      // footer line
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(40, 452); ctx.lineTo(472, 452); ctx.stroke();
      ctx.fillStyle = "rgba(169,179,193,0.95)";
      ctx.font = "600 18px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
      ctx.fillText("clickless • drive & interact", 40, 484);

      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.anisotropy = 8;
      tex.needsUpdate = true;
      return tex;
    }

    function roundRect(ctx, x, y, w, h, r, fill, stroke) {
      if (typeof r === "number") r = { tl: r, tr: r, br: r, bl: r };
      ctx.beginPath();
      ctx.moveTo(x + r.tl, y);
      ctx.lineTo(x + w - r.tr, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r.tr);
      ctx.lineTo(x + w, y + h - r.br);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
      ctx.lineTo(x + r.bl, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r.bl);
      ctx.lineTo(x, y + r.tl);
      ctx.quadraticCurveTo(x, y, x + r.tl, y);
      ctx.closePath();
      if (fill) ctx.fill();
      if (stroke) ctx.stroke();
    }

    function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
      const words = text.split(" ");
      let line = "";
      let yy = y;
      for (let n = 0; n < words.length; n++) {
        const testLine = line + words[n] + " ";
        const metrics = ctx.measureText(testLine);
        if (metrics.width > maxWidth && n > 0) {
          ctx.fillText(line.trim(), x, yy);
          line = words[n] + " ";
          yy += lineHeight;
        } else {
          line = testLine;
        }
      }
      ctx.fillText(line.trim(), x, yy);
    }

    function loadTexture(def){
      if(def.imageUrl){
        // If you supply URLs, ensure CORS headers allow image loading.
        const loader = new THREE.TextureLoader();
        return new Promise((resolve, reject) => {
          loader.load(def.imageUrl, (tex) => {
            tex.colorSpace = THREE.SRGBColorSpace;
            tex.anisotropy = 8;
            resolve(tex);
          }, undefined, reject);
        });
      }
      return Promise.resolve(makeCardTexture(def.name, def.tag));
    }

    // Procedural “expanding landscape”: spawn billboards in rings as player reaches distances
    const rings = [
      { radius: 18, count: 4, ids: ["productive","geometry","routing","skeptic"] },
      { radius: 34, count: 6, ids: ["punks","bayc","azuki","doodles","pudgy","milady"] },
      { radius: 54, count: 6, ids: ["nakamigos","clonex","moonbirds","coolcats","punks","azuki"] },
    ];
    const spawnedRing = new Set();

    const billboardState = []; // {mesh, def, pos, interactRadius}
    const billboardMatBase = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      roughness: 0.9,
      metalness: 0.05,
      transparent: true,
      opacity: 0.96
    });

    async function spawnRing(index){
      if (spawnedRing.has(index)) return;
      spawnedRing.add(index);

      const ring = rings[index];
      if(!ring) return;

      // Place evenly around circle, but with a little jitter
      for(let i=0;i<ring.ids.length;i++){
        const id = ring.ids[i];
        const def = BILLBOARD_DEFS.find(d => d.id === id) || BILLBOARD_DEFS[i % BILLBOARD_DEFS.length];
        const a = (i / ring.ids.length) * Math.PI * 2 + (Math.random()*0.22 - 0.11);
        const r = ring.radius + (Math.random()*2.2 - 1.1);
        const x = Math.cos(a)*r;
        const z = Math.sin(a)*r;

        const tex = await loadTexture(def);
        const mat = billboardMatBase.clone();
        mat.map = tex;
        mat.emissive = new THREE.Color(0x000000);
        mat.emissiveIntensity = 0.0;

        const planeGeo = new THREE.PlaneGeometry(5.2, 5.2);
        const mesh = new THREE.Mesh(planeGeo, mat);
        mesh.position.set(x, 2.8, z);
        mesh.rotation.y = -a + Math.PI; // roughly face inward
        mesh.userData = { def };
        billboardGroup.add(mesh);

        // a thin base post
        const post = new THREE.Mesh(
          new THREE.CylinderGeometry(0.09, 0.11, 2.4, 12),
          new THREE.MeshStandardMaterial({ color: 0x1b2430, roughness:0.95 })
        );
        post.position.set(x, 1.2, z);
        billboardGroup.add(post);

        billboardState.push({ mesh, def, interactRadius: 3.2 });
      }

      toast(`Unlocked new zone <b>${index+1}</b> / ${rings.length}`);
    }

    // Spawn first ring immediately
    await spawnRing(0);

    // -----------------------------
    // UI: panel + interactions
    // -----------------------------
    const hint = document.getElementById("hint");
    const backdrop = document.getElementById("backdrop");
    const panelTitle = document.getElementById("panelTitle");
    const panelSub = document.getElementById("panelSub");
    const panelBody = document.getElementById("panelBody");
    const panelClose = document.getElementById("panelClose");

    function openPanel(def){
      panelTitle.textContent = def.name;
      panelSub.textContent = def.tag ? `Tag: ${def.tag}` : "";
      panelBody.innerHTML = `
        <p><b>Primer</b> — ${escapeHtml(def.primer || "")}</p>
        <p><b>How cubixles relates</b> — ${escapeHtml(def.relate || "")}</p>

        <h4>cubixles in one breath</h4>
        <div class="mono">
cubixles_ mints ERC-721 derivatives whose identity is defined by NFTs you already own.
You don’t put NFTs in. You point at them.
The derivative is a tradable record of an executed configuration: context becomes a first-class market object.
        </div>

        <h4>Builder track: skeptic checks</h4>
        <ul>
          <li><b>No custody:</b> your referenced NFTs never leave your wallet.</li>
          <li><b>Legible pricing:</b> quote-based base + % of snapshot floor sum.</li>
          <li><b>Value routing:</b> references induce mint-time payouts (when compatible) and you own the per-token royalty forwarder.</li>
        </ul>

        <div class="cta">
          <b>Try it:</b> mint a 1-face cube first (lowest cost). Verify that nothing is wrapped or escrowed.
          Then mint a 6-face cube that actually expresses a curatorial thesis.
        </div>
      `;
      backdrop.classList.add("open");
      backdrop.setAttribute("aria-hidden","false");
      document.body.style.overflow = "hidden";
      panelClose.focus();
    }

    function closePanel(){
      backdrop.classList.remove("open");
      backdrop.setAttribute("aria-hidden","true");
      document.body.style.overflow = "";
    }

    panelClose.addEventListener("click", closePanel);
    backdrop.addEventListener("click", (e) => { if(e.target === backdrop) closePanel(); });
    window.addEventListener("keydown", (e) => {
      if(e.key === "Escape" && backdrop.classList.contains("open")) closePanel();
    });

    function escapeHtml(s){
      return (s ?? "").replace(/[&<>"']/g, (c) => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
      }[c]));
    }

    // -----------------------------
    // Map overlay (simple radar)
    // -----------------------------
    const mapBox = document.getElementById("map");
    const mapCanvas = document.getElementById("mapCanvas");
    const mctx = mapCanvas.getContext("2d");
    function drawMap(){
      const w = mapCanvas.width, h = mapCanvas.height;
      mctx.clearRect(0,0,w,h);

      // background
      mctx.fillStyle = "rgba(0,0,0,0.35)";
      mctx.fillRect(0,0,w,h);

      // radar rings
      mctx.strokeStyle = "rgba(122,240,255,0.16)";
      mctx.lineWidth = 1.5;
      const cx = w/2, cy = h/2;
      [28, 56, 84].forEach(r=>{
        mctx.beginPath(); mctx.arc(cx,cy,r,0,Math.PI*2); mctx.stroke();
      });

      // player
      mctx.fillStyle = "rgba(124,255,155,0.9)";
      mctx.beginPath(); mctx.arc(cx,cy,4,0,Math.PI*2); mctx.fill();

      // dots
      const px = cubixleBody.position.x;
      const pz = cubixleBody.position.z;
      const scale = 1.5; // world->map
      for(const b of billboardState){
        const dx = (b.mesh.position.x - px) * scale;
        const dz = (b.mesh.position.z - pz) * scale;
        if(Math.abs(dx) > 100 || Math.abs(dz) > 100) continue;
        const x = cx + dx;
        const y = cy + dz;

        mctx.fillStyle = "rgba(122,240,255,0.75)";
        mctx.beginPath(); mctx.arc(x,y,3,0,Math.PI*2); mctx.fill();
      }
    }

    // -----------------------------
    // Input handling
    // -----------------------------
    const keys = new Set();
    let wantsInteract = false;
    let muted = true;

    window.addEventListener("keydown", (e) => {
      if (["INPUT","TEXTAREA"].includes(document.activeElement?.tagName)) return;
      keys.add(e.code);

      if(e.code === "Enter") wantsInteract = true;
      if(e.code === "KeyR") respawn();
      if(e.code === "KeyM") toggleMap();
      if(e.code === "KeyL") toggleAudio();
      if(e.code === "Slash") { /* reserved */ }
    });
    window.addEventListener("keyup", (e) => {
      keys.delete(e.code);
      if(e.code === "Enter") wantsInteract = false;
    });

    // Buttons
    document.getElementById("btnRespawn").addEventListener("click", respawn);
    document.getElementById("btnHelp").addEventListener("click", () => {
      const c = document.getElementById("controls");
      c.style.display = (c.style.display === "none" ? "block" : "none");
    });
    document.getElementById("btnQuality").addEventListener("click", () => {
      // Toggle pixel ratio
      const current = renderer.getPixelRatio();
      if(current > 1.1){
        renderer.setPixelRatio(1);
        toast("Quality: <b>low</b> (performance)");
      }else{
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        toast("Quality: <b>high</b>");
      }
      renderer.setSize(innerWidth, innerHeight);
    });
    document.getElementById("btnAudio").addEventListener("click", toggleAudio);

    // Audio: simple WebAudio hum (no external assets)
    let audioCtx = null;
    let osc = null;
    let gain = null;

    function toggleAudio(){
      muted = !muted;
      if(!audioCtx){
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        osc = audioCtx.createOscillator();
        gain = audioCtx.createGain();
        osc.type = "sine";
        osc.frequency.value = 55;
        gain.gain.value = 0.0;
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
      }
      if(!muted){
        audioCtx.resume?.();
        gain.gain.setTargetAtTime(0.02, audioCtx.currentTime, 0.05);
        toast("Audio: <b>on</b>");
      }else{
        gain.gain.setTargetAtTime(0.0, audioCtx.currentTime, 0.06);
        toast("Audio: <b>off</b>");
      }
    }

    function toggleMap(){
      mapBox.style.display = (mapBox.style.display === "none" || !mapBox.style.display) ? "block" : "none";
    }

    function respawn(){
      cubixleBody.position.set(0, 1.2, 0);
      cubixleBody.velocity.set(0,0,0);
      cubixleBody.angularVelocity.set(0,0,0);
      heading = 0;
      speed = 0;
      toast("Respawned to <b>origin</b>");
    }

    // -----------------------------
    // Proximity interaction logic
    // -----------------------------
    let nearest = null;

    function updateInteraction(){
      nearest = null;
      const px = cubixleBody.position.x;
      const pz = cubixleBody.position.z;

      let bestD = Infinity;
      for(const b of billboardState){
        const dx = b.mesh.position.x - px;
        const dz = b.mesh.position.z - pz;
        const d = Math.hypot(dx, dz);

        // highlight nearby
        const mat = b.mesh.material;
        const near = d < 6.0;
        mat.emissive = mat.emissive || new THREE.Color(0x000000);
        mat.emissiveIntensity = near ? 0.45 : 0.0;

        if(d < b.interactRadius && d < bestD){
          bestD = d;
          nearest = b;
        }
      }

      if(nearest){
        hint.style.display = "block";
        hint.innerHTML = `Press <strong>ENTER</strong> to inspect <strong>${nearest.def.name}</strong>`;
      }else{
        hint.style.display = "none";
      }

      if(nearest && wantsInteract && !backdrop.classList.contains("open")){
        wantsInteract = false;
        openPanel(nearest.def);
      }
    }

    // -----------------------------
    // Movement: drive the cubixle
    // -----------------------------
    const clock = new THREE.Clock();
    let lastTime = performance.now();

    function step(dt){
      // Spawn rings as you reach distances (expanding landscape)
      const dist = Math.hypot(cubixleBody.position.x, cubixleBody.position.z);
      if(dist > 12) spawnRing(1);
      if(dist > 30) spawnRing(2);

      // yaw control
      const left = keys.has("KeyA") || keys.has("ArrowLeft");
      const right = keys.has("KeyD") || keys.has("ArrowRight");
      const forward = keys.has("KeyW") || keys.has("ArrowUp");
      const back = keys.has("KeyS") || keys.has("ArrowDown");
      const boost = keys.has("ShiftLeft") || keys.has("ShiftRight");
      const jump = keys.has("Space");

      const turnRate = (boost ? 2.4 : 1.8);
      if(left) heading += turnRate * dt;
      if(right) heading -= turnRate * dt;

      // speed update
      const accel = (boost ? 20 : 12);
      const maxSpeed = (boost ? 22 : 14);
      const decel = 9;

      if(forward) speed += accel * dt;
      else if(back) speed -= accel * dt;
      else {
        // natural slow
        speed -= Math.sign(speed) * decel * dt;
      }
      speed = THREE.MathUtils.clamp(speed, -maxSpeed*0.6, maxSpeed);

      // apply velocity in heading direction
      const fx = Math.sin(heading);
      const fz = Math.cos(heading);
      cubixleBody.velocity.x = fx * speed;
      cubixleBody.velocity.z = fz * speed;

      // keep upright: set quaternion yaw only
      cubixleBody.quaternion.setFromEuler(0, heading, 0);

      // hop if on ground-ish
      const onGround = Math.abs(cubixleBody.position.y - 1.2) < 0.28 || Math.abs(cubixleBody.velocity.y) < 0.05;
      if(jump && onGround){
        cubixleBody.velocity.y = 6.2;
      }

      // ambient hum follows speed
      if(audioCtx && osc && gain && !muted){
        const targetHz = 45 + Math.min(120, Math.abs(speed)*6);
        osc.frequency.setTargetAtTime(targetHz, audioCtx.currentTime, 0.06);
        const targetGain = 0.012 + Math.min(0.02, Math.abs(speed)*0.0015);
        gain.gain.setTargetAtTime(targetGain, audioCtx.currentTime, 0.08);
      }
    }

    // -----------------------------
    // Render loop
    // -----------------------------
    function animate(){
      requestAnimationFrame(animate);

      const dt = Math.min(1/30, clock.getDelta());

      if(!backdrop.classList.contains("open")){
        step(dt);
      }

      world.step(1/60, dt, 3);

      // Sync visuals with physics
      cubixleMesh.position.copy(cubixleBody.position);
      cubixleMesh.quaternion.copy(cubixleBody.quaternion);

      // target orbit controls to follow cubixle
      controls.target.copy(cubixleMesh.position);
      controls.update();

      // Make billboards face camera gently (billboard effect)
      for(const b of billboardState){
        b.mesh.lookAt(camera.position.x, b.mesh.position.y, camera.position.z);
      }

      updateInteraction();

      if(mapBox.style.display === "block"){
        drawMap();
      }

      renderer.render(scene, camera);
    }
    animate();

    // Resize
    addEventListener("resize", () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // Start muted by default; show a toast hint
    toast("Drive the <b>cubixle</b> → reach billboards → <b>ENTER</b> to read.");
  </script>

  <!--
    Run locally with a server (modules need it):
      python -m http.server 8000
    then open:
      http://localhost:8000/this-file.html
  -->
</body>
</html>
